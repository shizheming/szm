<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>relationship</title>
</head>
<body>
    
</body>
</html>
<script src="../js/libs/ecma.js"></script>
<script src="../js/system/relationship2.0.js"></script>
<script>

function a () {
    alert(arguments.callee.name);
}
function b () {
    alert(arguments.callee.name);
}
function c () {
    alert(arguments.callee.name);
}
function d () {
    alert(arguments.callee.name);
}
function e () {
    alert(arguments.callee.name);
}
function f () {
    alert(arguments.callee.name);
}
function g () {
    alert(arguments.callee.name);
}
function h () {
    alert(arguments.callee.name);
}
function i () {
    alert(arguments.callee.name);
}


// 改进成这样的，不要用户记key的名字
// 不过我觉得记维度还是回比记个可以难，因为维度要数，key这要看，当然key容易
/*var relationshipTable = [
    [a, [b, c, d]], 
    [b, c], 
    [[e, f, g], d], 
    [[a, c, e], [b, d]]
];
*/





var relationshipTable = [{
    n : b,
    rn : c
}, {
    n : c,
    rn : [d, a, g]
}, {
    n : h,
    rn : g
}, {
    n : a,
    rn : b,
}, {
    n : [c, g],
    rn : f
}, {
    n : f,
    rn : i
}];

// 我先想到的是把它们全部通过一对一的方式罗列出所有的可能，有个坑就是当2个关系相互引用的时候，我在动态的输出每一条到底的关系线是就会就如死循环，a引用b，b引用a，a在引用b，b在引用a。。。。。。这样无线循环，这个要解决下，什么时候停下来，我想了下，当他的关系接受来源和他的关系目的点是一样的时候就停止
/*
[a,b,c,d]
[a,b,c,f]
*/



// 其实我觉得本质上就都是一对一，只是一对一多了后，自然而然就产生了一对多，多对一，多对多，虽然本质的理论上是就是一对一，但这是要对用户用的，人们总是希望这东西越简单越强大越方便的使用，所以多肯定是要的，多是一提升的一种形式，就像洗衣机的各种模式一样，本质上没有什么模式，有的只是时间转速温度的不一样，而那么多组合人们是记不住的，所以把一套的参数提升到模式的形式后，便于人类的理解而已，方便

console.log(_.relationship(relationshipTable));
/*
    形式
    可以有很多形式，各种样子的，但最终只有一种样子形成，我是想把所有的形式揉捏在一起吗，弄个最完美的吗，既然有形，肯定是不完美的，只有无形才是最完美的，因为可以变成任何形状，
    1. 就是上面这种，只有一和多
    2. 在上维度
        var relationshipTable = [{
            n : a1,
            rn : {
                n : a2,
                rn : {
                    n : {
                        n : a6,
                        rn : a7
                    },
                    rn : [a4, a5]
                }
            }
        }];
    3. 这种就是无形的，没有表，直接依附对象
        a1.rn = a2;
        a3.rn = a4;
        a5.rn = [a1,a2,a3];
        现在想想结构赋值就是一种多对一的体现，厉害

    老实说，我现在很麻乱，一团糟，我不害怕之前的概念被自推翻，但推翻之后的混沌让我好痛苦，找不到方向，再次的又不知从哪里开始，头在哪，想着把一切概念一网打尽，一口吃个大胖子



    凭空想象那个最初的东西相当的难，不符合人的思考方式，那我就从人的角度来思考，从我开始好不好，没有我哪来世界，完全从主管出发，因为客观太难了，我之所以能思考，能想，是因为有感官，听觉，视觉，嗅觉，触觉，味觉，如果5官全失，我还能感觉到我存在嘛，我还能感觉到我思考嘛，我觉的不能，思考就是对外界的一切反应，那有了我，有了五感，然后就是客观的时间和空间，具备了这4大条件因素，结论就是我思故我在了，接着在对代码世界的认识中五感就只剩下视觉，视觉给的信息就是样子，形状，外观，那么什么东西有形，必须是实体，概念无形，是存在于大脑中，所以不是实体，但我们有时候是需要概念实体化的，单单留在脑中无法解决问题，比如，民警在办案时会在黑板上划出一个嫌疑人的关系图，那么关系这种无形的概念就立即被实体化了，这就是概念实体化，回到代码，前不久纠结于是把关系挂在实体上，还是写个关系表，现在来看2者没有对错，关系表就是一种概念实体化，既然是实体，必有广延，就是三维，之前是2位，现在要加上深度，也就是嵌套，之前维度的问题也就解决了，是的，需要的，因为他是实体，加上本身有数的概念，一个静止的实体就诞生了，有了静止相对的运动也就呼之欲出了，怎么体现，加方法，增加关系，删除关系，替换关系，查看关系，这些都能叫修改，但我不能只有这个方法，在现实中一般会有多个目的性的方法，这只能在哲学上达到一与多的统一，好，运动有了随之而来的就是间断性和连续性，很顺的就过来了，恩，之前的问题都理通了，从我回到了客观的那4个出发点，nice，嘻嘻。

    虽然之前实体的维度概念确认加进去了，但是在实际把深度添加进去以后发现，并不能正确的体现关系的形，因为他是层层嵌套的，有包裹的层级概念，但关系之间连续性是平级的，没有里外的形式，只有平面方向的位置关系，所以json的对象维度包裹并不适合。我得寻找另一种形式，宗旨是人们对于扁平化的图更好理解，因为简单不复杂，所以现在就是不能通过json数据格式本身的嵌套形式来表现维度的概念，我需要寻找另一种形式来体现，或者是，和原来一样，没有深度，虽然从概念上来说并不完美，但概念并不强制，最后还是回到原来吧，从人的理解上来，扁平化最容易接受，因为简单，好，先这样

    还有一个问题就是为什么没有理清之前加上维度，是这样的，如果单纯是扁平化的那么，是解决了a和b，b和c的单一关系，这就是间断性，但没有解决a和b和c的关系，也就是连续性，我觉得这才是我当初增加维度的初衷，后来把这个维度理解成实体化的深度，把他作为了一个形，这个深度看来要找其他的出入了，

    所以我先得解决连续性的问题
*/ 

</script>