<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Untitled Document</title>
<script type="text/javascript">
/*changecolor();//output color="blue"然后在往下读var color="blue"
var color="blue";
function changecolor(){
	if(color=="blue"){
		color="red";
	}else{
		color="blue";
	}
};
alert(color)*/


/*var colors=[435,6788];
var count=colors.unshift("fgwe");//unshift push返回的是他的长度
alert(colors)

var aaa=["red","green"]
var bbb=aaa.concat("blue","yellow")
alert(bbb)
*/


/*function bigorsmall(a,b){
	return a>b//a>b a<b
}
var ooo=[23,3,14,7];
alert(ooo.sort(bigorsmall))
1;	23-3=20
	(3,23,14,7)
	23-14=9
	(3,14,23,7)
	23-7=16
	(3,14,7,23)
2;	3-14=-11
	(3,14,7,23)
	14-7=7
	(3,7,14,23)
	14-23=-9
	(3,7,14,23)*/


/*var ii=[1,2,3,23,234,23434,345,235456,7856];
var aa=ii.splice(0,2)
	aa=ii.splice(2,4,"f1","f2")//第2位开始后面删4个
alert(ii)*/


/*alert(aa());
function aa(){return 44}
alert(aa());
var bb=function aa(){return 44}*/


/*function shi(a,b,c){
	return a(b,c);
};
function zhe(bb,aa){
	return bb+aa;
};
var ming=shi(zhe,99,88);
alert(ming)*/


/*function shi(sss){
	return zhe();
};
function zhe(zzz,hhh){
	var zzz=111;
	var hhh=222;
	return zzz+hhh;
};
//var ming=zhe(111,222);
alert(shi())*/


/*function fuckyou(bb){
	if(bb<=1){
		return "1";
	}else{
		return arguments.callee(bb-1);
	};
};
alert(fuckyou(5))*/


/*var string1="kfgkshgjsdkhgmvkidhsfgvbughkjg";
var suzu=[];
var pos=string1.indexOf("g");
while(pos>-1){
	suzu.push(pos);
	pos=string1.indexOf("g",pos+1);
};
alert(suzu)*/


/*var a=[1,45];
var b=a;
a[0]=99;
alert(b)*/


/*var u=1;
var j=u++;
alert(u);
alert(j)
*/


/*var uuu={
	q:2,
	y:0,
	g:7,
	t:2,
	k:5,
};
for(var fuck in uuu){
	document.writeln(fuck+"")
}*/


/*var i={k:123434,h:"fewwer"};
alert(i.k)//=i["k"]*/


/*var imun=0;
outermost:
	for(var i=0;i<10;i++){
		for(var j=0;j<10;j++){
			if(i==5&&j==5){
				break outermost//跳出外部循环所以次数会少
			}
		}
	}*/


/*var i=function(){alert(111)};//匿名函数要付之于一个变量，然后变量加（）来调用,匿名函数是函数表达式
i()*/


//(function(){alert("jjjj")})()//（）里放函数表达式，不能有函数名


/*function er(){
	for(var i=0,a=[];i<arguments.length;i++){
		a.push(arguments[i]);
	};
	alert(a);
};
er(345,546354,23452534,57868,6795,3456374,5678);*/

//66页
//79页
//112页


/*var n=1;
var m=n;
function add(ss,oo){
	alert(ss+=oo);//这里只是传n的值也就是复制了一个1给函数的形参，外面n的初始化时不变的，他引用的是变量的值而不是变量明
};
add(n,m)
alert(n)*/


//既然没有块级作用域if和for里面的var初始化变量能在外部访问而函数里的var初始化变量为什么不能再外部访问


/*function sum(a,b){
	return (a+b);
};
sum=null;//先赋予空在anothwesum指向sum函数就是空
var anothersum=sum;
sum=null;//anothersum先指向sum函数，然后sun再被赋予空，因为他先指向了所以能调用
alert(anothersum(10,10))*/


/*function fff(num){
	if(num<=1){
		return 1;
	}else{
		return (num*arguments.callee(num-1));//5*4*3*2(当递归1的时候就返回if的前半句就返回了1所以在乘1)=120
	}
};
var uuu=fff;
	fff=0;
alert(uuu(5));
alert(fff)*/


/*function aa(name,age,job){
	var t={
		name:name,
		age:age,
		job:job,
		fangfa:function(){
			alert(this.name)
		}
	};
	return t;
};
aa("ferf",4545,"fwerf");
cc.fangfa()*/


/*function aaaa(name,age){
	var o=new Object();
		o.name=name;
		o.age=age;
		o.say=function(){alert(this.name)};
		return o
};
var h=aaaa("kkk",99);
	alert(h.age)
//alert(h instanceof aaaa)*/


/*function a(name,age,sex){
	this.name=name;
	this.age=age;
	this.sex=sex;
	this.say=function(){alert(this.name)};
	
};
var szm=new a("shizhimg",25,"man");
	szm.say()
//var szm2=new a("shizhimg",25,"man")//这里2个new就是实例化了2次而不是引用不是物理的而是化学的反应创建了2个新对象
//alert(a instanceof Object)*/


/*function person(){
	person.prototype.name="asdasdasd";
	person.prototype.say=function(){alert(this.name)}
};
var aaa=new person();
var bbb=new person();
alert(aaa.name)*/


/*function aaa(){
	var i={};
	i.qwe=123;
	i.asd=456;
	i.zxc=789;
	return i;
};
var g=aaa()//为什么这样就能调用i的属性了  工厂模式？
alert(g)//g弹出来是object所以就可以直接跟g.i的属性*/


/*function yu(){
	//var yu={}
	yu.one=8888;//yu是function所以不用声明就有属性
	return yu
};
var g=yu();
alert(typeof yu)*/


/*function aa(){
	this.bb=[12];
};
function qwe(){
	//qwe.prototype=new aa();//写这里oo.bb就调不到,写外面就调得到
};
qwe.prototype=new aa();
var q2=new qwe();
var q3=new qwe();
q2.bb.push(44)
alert(q2.bb);
alert(q3.bb)*/






/*function fn(n){
	for(var i=ret=1;i<=n;i++){
		ret=ret*i;
	};
	return ret;
};
alert(fn(5))*/


//this默认指向wingdow,window是对象，当用new的时候就创建了一个新对象，this指向的是对象


/*function fn(){
	var i=0;
	for(;i<10;i++){}
	function fn1(){alert(i)};
	return fn1;//返回fn1函数给上下文，而不是返回最终值，如果是fn1()就是执行这个函数
};
var qq=fn()
qq()*/


/*function fn(){
	fn.prototype={sss:123};//写在里面和外面不一样，里面重写prototype后就访问不到了
};
var h=new fn();
alert(h.sss);*/


/*var ooo=999;
function qq(){return 33}
alert(window.qq())//变量名变成属性了？window可以访问所有的全局变量*/


/*function Box(name,age){
	this.name=name;
	this.age=age;
	alert(1)
	Box.prototype.run=function(){
		return this.name+this.age;
	};
	alert(2)
};
var box1=new Box("lee",100);
alert(box1.run());
var box2=new Box("jack",200);
alert(box2.run())
*/


/*function Demo(user,age){
	//this.user=user;
	this.age=age;
	Demo.prototype.user=1;
	//this.prototype.user=1;
};
var demo=new Demo("szm",25);
//demo.user=2
alert(demo.user)*/


/*function Demo(){}
Demo.prototype.aaa=1;
Demo.prototype={
	bbb:2,
}
var demo=new Demo();
alert(demo.aaa)*/



/*function f1(num){
	if(num<=1){
		return 1;
	}else{
		return num*f1(num-1);
	};
};
var f2=f1;
f1=2;
//f1=function(){return 0}
alert(f2(5))*/


/*function cc(){
	var rr=[];
	for(var i=0;i<10;i++){
		rr[i]=function(){
			return i;
		};
	};
	return rr;
};
var ff=cc()//下面i<ff.length和i<cc().length有什么不一样，一个是引用，一个是立即执行函数然后接着length吗
for(var i=0;i<cc().length;i++){alert(cc()[i]())}
//alert(cc()[7]())
*/


/*function qwe(){
	for(var i=0,jj=[];i<10;i++){
		jj[i]=function(){
			return i
		};
		
	};//走了一遍i已经是10了
	return jj
}
alert(qwe()[1])

//碧包函数执行完后变量不销毁,二下面的i执行完后已经是10了
[function(){return 10},function(){return 10},function(){return 10},function(){return 10},function(){return 10},function(){return 10},function(){return 10},function(){return 10},function(){return 10},function(){return 10}][0]
[function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i}][1]
[function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i}][2]
[function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i}][3]
[function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i}][4]
[function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i},function(){return i}][5]

function qwe(){
	for(var i=0,jj=[];i<10;i++){
		jj[i]=i
		
	};
	return jj
}
//var qq=qwe()
//alert(qq.length)
for(var v=0;v<10;v++){
	alert(qwe()[v])
}
[1,2,3,4,5,6,7,8,9][0]
[1,2,3,4,5,6,7,8,9][1]
[1,2,3,4,5,6,7,8,9][2]
[1,2,3,4,5,6,7,8,9][3]
[1,2,3,4,5,6,7,8,9][4]*/







//26
//29
//30
//56
//57
//58
//62
//63
//64
//66
//69
//75
//77
//78
//80
//81
//95
//98
//113
//116
//131
//136
//137
//145
//146
//147


/*if(true){
	var u=3;
}
alert(u)//没有块级作用域for也是function除外*/


/*var aa=function(){return 8888;};
var bb=new aa();
//等号左边变量是赋值的意思不是指针，等号右边才是指针*/


//创建一个function就是创建对象，一般为函数也是对象就等于new function一样，new操作符就是创建的意思，是动态的，所以在实例化一个构造函数的时候，里面的方法也会重新创建一个新的，也就是实例化几个构造函数就有几个不同的方法


/*function tt(job){
	this.job=job;
	tt.prototype.oo=function(){return job}
};
var pp=[1,2]
var qq1=new tt(function(){});//var qq1=new tt(pp);var qq1=new tt([1,543]);
var qq2=new tt(function(){});//var qq1=new tt(pp);var qq1=new tt([1,543]);结果是不一样的
alert(qq1.job==qq2.job)*/


/*function tt2(){
	this.job=jj;//this.job=[0]结果不一样，直接在构造函数内部赋值引用类型，当被实例化的时候是不相等的，而用指针指向构造函数外部的引用类型时是相等的
	tt2.prototype.oo=function(){return job}
};
var jj=[0]
var qq3=new tt2();
var qq4=new tt2();
alert(qq3.job==qq4.job)*/


/*function qq(){
	this.abc="giefi";//实例属性
	qq.prototype.zxc=352345;//原型属性
};
var p=new qq();
p.uu="432rfef"//实例属性*/


/*function aa(){aa.prototype.aa1=function(){return 1111};};
function bb(){};
bb.prototype=new aa();//这个要写在构造函数外面才能获取到
var cc=new bb();
alert(cc.aa1());
*/


//3.5
//5.3
//5.4
//6.2.4
//6.2.5
//6.2.6
//第七章

/*function a1(){return 2;};//把函数名想成一个指向函数体的指针就容易理解了
var dd=a1;
a1=null;
alert(dd())
alert(a1())*/
















</script>
</head>

<body>

</body>
</html>
