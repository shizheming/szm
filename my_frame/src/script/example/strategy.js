import strategy from '../strategy/strategy';
export const map = ['strategy'];
export const key = 'strategy';
export default function () {
    /*
        时间：2018.10
        
        策略：（属性，一和多，静和动，时间和空间，间断和连续：体现在运动上，函数的调用运行上，我想到的是给函数打点，不单单体现在柯理化参数上）
            1.必须要有判断条件（√）
            2.引入空间，把条件头和条件体分开来（空间：有什么构成）（√）
            3.引入时间，添加条件头，删除条件头，添加条件体，删除条件体，同时也就有了属性方法（这个现在看起来好像需要，因为判断是一下子就完成了，不会触发第二次）（√）
            4.条件头和条件体也是一一对应的关系的，一对多也就是一对一的辩证，所以也就解决了一和多的关系(增加多，要满足多条件成立，才执行条件体)（√）
            5.间断性和连续性
                参数上体现的间断性就是柯理化条件参数和条件体参数
                那参数上的连续性就写在一次调用上
                1. 上面是参数的间断性和连续性（待定）
                2. 连续性其实运行函数后本身就是个连续性的过程，所以我要做的只是如何实现间断性，打点的方式会有很多，我找了个立足点，那就是从这要方法本身是干什么的切入，这个叫策略的方法是由条件头和执行体构成的，从目的论的观点来看，策略的目的就是要找那个对的适合的策略，从众多的选择中找出那个需要的，符合条件的，我们姑且说是成功的，因为失败的会有超级多，而成功的只有一个，所以我就在成功判断条件体后打个点，就在那，表示方法本身的一个间断性。（√）
            6.我还得考虑一个就是函数的返回值，我怎么接，这个不关乎概念，只是代码本身的具体表现（√）
            7.增加返回数据之间传递的多参数（√）
            8.添加关系表能动态修改的反映（把条件头的一和执行体的一都变成多，这样就能利用引用来达到动态添加和删除关系表中的数据的目的了）
        比较：
            粗略一看，策略和状态在设计模式中颇为相似，他们最终的方法都是通过多态来实现的，这就是内容，上升到形式就是一个状态，一个策略，策略是对象达到目的的方案是外部的，而状态是对象内部的变化，就像之前写的关系，顺序，这些都是外部的，同样策略也是外部的，这些事构成体系关系之间的各种因素联系，而对象是各种联系存在的大前提，是基础，状态就是依附于对象来说的
        问题：
            1. 上面添加了多，就是当全部条件都满足的时候才执行，遗留的问题是这个在当在多的时候想用一，也就是只要符合其中的任何一个提交就执行，这个我需要怎么设计
    */

    function c1 (a, b) {
        return a > b;
    }
    function c2 (a, b) {
        return a + b === 3;
    }
    function c3 (a, b) {
        return a === b;
    }
    function c4 (a, b) {
        return a < b;
    }

    function s1 (v) {
        alert('a > b, a + b === 3' + v);
        return 's1';
    }
    function s2 (a, b, c) {
        alert('a + b === 3');
        console.log(a, b, c);
    }
    function s3 () {
        alert('a === b');
    }
    function s4 (v, h, j) {
        alert('s4' + v + '++++++' + h + '+++++' + j);
        return 's4';
    }
    function s5 (v) {
        alert('s5' + v);
    }

    var relationshipTable = [{
        n: [c1, c2],
        rn: [s1, s4]
    }, {
        n: c4,
        rn: s2
    }, {
        n: c3,
        rn: [s3, s4, s5]
    }];

    var u1 = strategy(relationshipTable, function (a, b, c) {
        console.log(a, b, c);
        return ['我是间断性', 'hi'];
    });
    // relationshipTable[0].n.push(c3);
    // relationshipTable[0].n.pop();
    var u2 = u1(2, 10);
    // relationshipTable[1].rn.push(s5);
    var u3 = u2(11212444, 99999);
    var u4 = u3('heheda');
}