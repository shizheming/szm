<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>test</title>
	<style type="text/css">
	.list1,.list2,.list3{width:300px;line-height:40px;border:2px solid #333;margin:20px;font-size:22px;text-align:center;}
	#div2,#div3,#div4{padding:10px;border:1px solid #ccc; }
	</style>
</head>
<body>
	<div id="div2">
		<div class="list1" style="background:#D8BFD8">1</div>
		<div class="list1" style="background:#EE7600">2</div>
		<div class="list1" style="background:#BFEFFF">3</div>
		<div class="list1" style="background:#9ACD32">4</div>
		<div class="list1" style="background:#8F8F8F">5</div>
		<div class="list1" style="background:#8B5A00">6</div>
	</div>
	<div id="div3">
		<div class="list2" style="background:#D8BFD8">1111</div>
		<div class="list2" style="background:#EE7600">2222</div>
		<div class="list2" style="background:#BFEFFF">3333</div>
		<div class="list2" style="background:#9ACD32">4444</div>
		<div class="list2" style="background:#8F8F8F">5555</div>
		<div class="list2" style="background:#8B5A00">6666</div>
	</div>
	<div id="div4">
		<div class="list3" style="background:#D8BFD8">1111111111111111</div>
		<div class="list3" style="background:#EE7600">2222222222222222</div>
		<div class="list3" style="background:#BFEFFF">3333333333333333</div>
		<div class="list3" style="background:#9ACD32">4444444444444444</div>
		<div class="list3" style="background:#8F8F8F">5555555555555555</div>
		<div class="list3" style="background:#8B5A00">6666666666666666</div>
	</div>
</body>
</html>
<!-- <script src="underscore.js"></script> -->
<!-- <script src="vue.js"></script> -->
<script>

/*

写个链表，抛弃数组，数组的记录数字和索引太麻烦了，索引错了就全乱了，一不小心就给自己挖了大坑，然后数据反映dom节点，他们不是平级的状态，而是数据先dom节点后，当操作数据的时候反映到dom节点，所以我要写个数据操作和dom节点变化映射的关系，如果数据的插入等同于dom节点的插入，可以绑成一个数据动作，相当具象的映射关系



*/


var div2 = document.getElementById('div2');
var div3 = document.getElementById('div3');
var div3 = document.getElementById('div4');

var dragElement = null;


// var arrList = ['list1', 'list2'];
var arrList = ['list1', 'list2', 'list3'];
for (let i = 0, len = arrList.length; i < len; i++) {
	var ls = [].slice.call(document.querySelectorAll('.' + arrList[i]), '');
	arrList['list' + i] = ls;
	[].forEach.call(ls, function (item, index, arr) {
		bd(item, index, arr, i);
	});
}


function bd (item, index, arr, listIndex) {
	item.draggable = true;
	var eventList = [function (ev) {
		dragElement = item;
		// 我来自哪个大区
		dragElement.index = listIndex;
		// 绑定函数挂上，以后要解绑用
		dragElement.eventList = eventList;
		// 当前自身的索引
		dragElement.myIndex = index;
		// console.log('dragstart');
	}, function (ev) {
		ev.preventDefault();
		// console.log('drop');
	}, function (ev) {
		// console.log(item, dragElement);
		
		if (item == dragElement) return;
		// console.log('dragenter');

		insert(item, index, arr, ev, listIndex);
		
	}, function () {
		
		// console.log('dragleave');
	}, function (ev) {
		ev.preventDefault();
		// console.log('dragover');
	}];
	eventList[0].evt = 'ondragstart';
	eventList[1].evt = 'ondrop';
	eventList[2].evt = 'ondragenter';
	eventList[3].evt = 'ondragleave';
	eventList[4].evt = 'ondragover';
	item.ondragstart = eventList[0];
	item.ondrop = eventList[1];
	item.ondragenter = eventList[2];
	item.ondragleave = eventList[3];
	item.ondragover = eventList[4];
}



function insert (item, index, arr, ev, listIndex) {
	
	// 是否外星来的
	if (!isExistence(arr, dragElement)) {
		// 你是外来生物

		item.parentNode.insertBefore(dragElement, item);
		// 同化--插到相应的位置
		arr.splice(index, 0, dragElement);

		// console.log(dragElement.index, listIndex);

		// 删除原来的地方
		arrList['list' + dragElement.index].splice(dragElement.myIndex, 1);

		// 重新绑定目标
		[].forEach.call(arrList['list' + listIndex], function (item, index, arr) {
			bd(item, index, arr, listIndex);
		});
		// 重新绑定来源
		[].forEach.call(arrList['list' + dragElement.index], function (item, index, arr) {
			bd(item, index, arr, dragElement.index);
		});
		// 更新值
		dragElement.myIndex = index;
		dragElement.index = listIndex;

		// console.log(arrList['list' + dragElement.index]);
		// console.log(arr);
		return;
	}
	// 本来物
	// 每次触及某个目标有可能只是经过，关键是一次性经过加越级了，跑到别人的地盘去了
	dragElement.myIndex = index;

	if (item == dragElement.nextElementSibling) {// 基本--相邻就互换位置
		// 插后面
		item.parentNode.insertBefore(dragElement, item.nextElementSibling);
		transposition(arr, arr.indexOf(dragElement), arr.indexOf(item));
		// console.log(arr, index);
	} else if (item == dragElement.previousElementSibling) {
		// 插前面
		item.parentNode.insertBefore(dragElement, item);
		transposition(arr, arr.indexOf(dragElement), arr.indexOf(item));
		// console.log(arr, index);
	} else if (item == item.parentNode.lastElementChild) {// 下面都不相邻了
		// 插尾巴
		item.parentNode.appendChild(dragElement);
		// 这里不能互换，因为是往前推和往后推的概念，像插队
		[].push.apply(arr, arr.splice(arr.indexOf(dragElement), 1));
		// console.log(arr, arr.indexOf(dragElement), arr.indexOf(item));
	} else {
		// 不相邻都插前面
		item.parentNode.insertBefore(dragElement, item);
		if (arr.indexOf(item) > arr.indexOf(dragElement)) {
			// 回到互换----前面插后面需要互换
			item.parentNode.insertBefore(dragElement, item.nextElementSibling);
		}
		arr.splice(arr.indexOf(item), 0, arr.splice(arr.indexOf(dragElement), 1)[0]);
		// console.log(arr);
	}
	// console.log(arr);
	// 重新绑定目标
	[].forEach.call(arrList['list' + listIndex], function (item, index, arr) {
		bd(item, index, arr, dragElement.index);
	});
}







































// 移形换位
function transposition (obj, key1, key2) {
	var third = obj[key1];
	obj[key1] = obj[key2];
	obj[key2] = third;
}


// 反转符合，跟其他具体的谓词函数合为一个整体
function reversePredicate (predicate) {
	return function () {
		return !predicate.apply(null, arguments);
	};
}


// 随机数字
function numberRandom (digit) { // 位数（值）默认9位
	var rd = Math.ceil(Math.random() * (digit ? Math.pow(10, digit) : Math.pow(10, 9)));
	return rd;
}

// 随机字母
function alphabetRandom (digit) { // 个数（值）默认9位
	var arr = [];
	for (var i = 0; i < (digit ? digit : 9); i++) {
		//生成一个0到25的数字
		arr.push(Math.ceil(Math.random() * 25));
	}
	//大写字母'A'的ASCII是65,A~Z的ASCII码就是65 + 0~25;然后调用String.fromCharCode()
	return String.fromCharCode.apply(null, arr.map(function (currentValue, index, array) {
		return currentValue + 65;
	}));
}

// 随机数字字母
function numberAlphabetRandom (digit) { // 位数（值）默认9位
	digit = digit ? digit : 9;
	var s = Math.random().toString(16);
	// 满足位数的同时满足有数字有字母
	// 以字母开头
	var d = /(?:\.[a-zA-Z]+\d+)/.test(s);
	return s.length > digit && d ? s.substr(2, digit) : numberAlphabetRandom(digit);
}


// 判断是否存在
// 存在一，存在多
function isExistence (where) { // 目的地（值），目标（值，方法）
	// 1. 数组中存在1，存在2，存在‘dsfsdf’，这些事具体的形
	// 2. 数组中存在数字，字符串，英文，标点，这些是一种抽象
	// 可以传具体的值，也能穿概念
	// 现在只是单个存在，要添加多个存在，不但存在一，还要存在多
	var args = [].slice.call(arguments, 1);
	var val = [];
	var predicate = [];
	args.forEach(function (item, index, arr) {
		typeof item == 'function' ? predicate.push(item) : val.push(item);
	});
	val = val.length == 0 ? true : val.every(function (item, index, arr) {
		return where.indexOf(item) > -1;
	});
	predicate = predicate.length == 0 ? true : predicate.every(function (item, index, arr) {
		return where.some(function (val, index, arr) {
			return item(val);
		});
	});
	return val && predicate;
}

// 重复做直到达到目标
var repeat = (function () {
	var arr = [];
	return function repeat (createVal, predicate) { // 条件（方法），怎样做（方法）
		// 创建一个新值
		var res = createVal();
		// 判断这个新值在某个条件中符合不符合
		// 如果符合就添加到数据中
		// 如果不符合接着递归直到符合
		if (predicate(arr, res)) {
			// 达到目的停止
			arr.push(res);
			return res;
		} else {
			// 没达到目的继续
			repeat(createVal, predicate);
		}
	}
})();


['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Array', 'Object'].forEach(function(element, index, array) {
	window['is' + element] = function(obj) {
		return Object.prototype.toString.call(obj) === '[object ' + element + ']';
	};
});



/*
函数
1.作为参数传进去给内部用，实参从内部获得
2.作为返回值传出去给外部用，实参从外部获得
*/




</script>
