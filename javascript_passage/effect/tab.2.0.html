<!----------------------------------

名称：tab.js
版本：2.0
时间：2016.11
更新：1.静态的tab切换变成动态的tab切换
      2.面向过程变成面向对象

---------------------------------->

<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title>tab切换</title>
	<style>
	.tab1{overflow:hidden;}
	.tab1>.title{overflow:hidden;}
	.tab1>.title{display:flex;}
	.tab1>.title>div{flex:1;background-color:#ccc;}
	.tab1>.content>div{display:none;background-color:#999;}
	.tab1>.title>.cur{background-color:#000;color:#fff;}
	.tab1>.content>.cur{display:block;}

	</style>
</head>
<body>

<script>







// data
function dd() {
	// 这是储存最原始的字符串内容
	this.title = [];
	this.content = [];

	// 我还要储存原始字符串生成的节点
	// 这样当节点改变的时候可以重排index同是绑定事件
	// 储存节点
	this.titleNode = [];
	this.contentNode = [];

	// 就检查一个头应该够了吧？？？？
	// 不够！
	// 如果头没换，内容换了呢，对不对！！
	// 检查原始字符串状态
	this.oldTitle = [];
	this.oldContent = [];


	// 激活flow方法
	// 激活了初始化方法后才能激活flow方法
	this.active = false;
	// 用户自定义函数
	this.fn = 0;
	// 变动的位置
	this.change = [];

	// 储存大节点以便之后动态更新tab的时候不需要去直接访问dom
	this.domTitle = '';
	this.domContent = '';

	// 记录上个激活标签的状态位置
	this.last = 0;

}

/*{
	title : '',
	content : ''
}*/

// 添加
dd.prototype.push = function(json) {
	this.title.push(json.title);
	this.content.push(json.content);
};

// 删除
dd.prototype.del = function(index) {
	// 不能用splice删，她会位移
	/*this.title.splice(index, 1);
	this.content.splice(index, 1);*/
	// 位置要保存着，才能对准位置来对比
	this.title[index] = undefined;
	this.content[index] = undefined;
};

// 检测
dd.prototype.flow = function() {
	if (!this.active) {
		alert('请先初始化nInit方法！');
		return;
	}

	// 先把上次改变的重置下
	this.change = [];
	
	

	for (var i = 0, len = this.title.length; i < len; i++) {
		// 有一个地方变动就要记录变动的位置，不管是头部还是内容
		if (this.title[i] != this.oldTitle[i] || this.content[i] != this.oldContent[i]) {
			this.change.push(i);
		}

	}


	var that = this;
	for (var i = 0, len = this.change.length; i < len; i++) {
		// 更新老节点
		this.oldTitle.splice(this.change[i], 1, this.title[this.change[i]]);
		this.oldContent.splice(this.change[i], 1, this.content[this.change[i]]);
	}


	this.nJeep();


};



dd.prototype.nJeep = function() {

	// 激活flow后的last计数器
	var last = this.last;

	var dl = this.title.length;

	for (var i = 0, len = this.change.length; i < len; i++) {
		// 判断是加还是删
		if (this.title[this.change[i]] === undefined && this.change[i] <= dl) {
			// 这是删
			var delTitle = this.titleNode.splice(this.change[i], 1);
			var delContent = this.contentNode.splice(this.change[i], 1);

			this.domTitle.removeChild(delTitle[0]);
			this.domContent.removeChild(delContent[0]);
			continue;
		}


		// 这是加
		var nodeT = createDiv(this.title[this.change[i]]);
		// nodeT.index = this.change[i];
		var nodeC = createDiv(this.content[this.change[i]]);
		// nodeC.index = this.change[i];

		// 添加新节点
		this.titleNode.push(nodeT);
		this.contentNode.push(nodeC);

		// 这里也要更新下节点

		this.domTitle.appendChild(nodeT);
		this.domContent.appendChild(nodeC);

	}
	

	// 删除数组中的undefined，如果是删除相的话
	for (var i = 0, len = this.title.length; i < len; i++) {
		if (this.title[i] === undefined) {
			// 原始值
			this.title.splice(i, 1);
			this.content.splice(i, 1);

			// 上次的原始值
			this.oldTitle.splice(i, 1);
			this.oldContent.splice(i, 1);
		}
	}

	// 分配新的下标
	for (var i = 0, len = this.title.length; i < len; i++) {
		this.titleNode[i].index = i;
		this.contentNode[i].index = i;
	}

	// 看看有没有把当前显示的删掉了，要加上
	// 你到底是有还是没有cur
	var overClass = false;
	for (var i = 0, len = this.titleNode.length; i < len; i++) {
		for (var j = 0,len2 = this.titleNode[i].classList.length; j < len2; j++) {
			this.titleNode[i].classList[j] == 'cur' ? overClass = true : 0;
		}
	}

	if (!overClass) {
		this.titleNode[0].classList.add('cur');
		this.contentNode[0].classList.add('cur');
	}


	// 变动的节点重新绑定事件
	for (var i = 0; i < this.title.length; i++) {
		var that = this;

		this.titleNode[i].addEventListener('touchstart', (function(i, nodeC) {
			return function() {
				if (last == this.index) return;

				this.classList.add('cur');
				nodeC.classList.add('cur');
				// alert(last);
				that.titleNode[last].classList.remove('cur');
				that.contentNode[last].classList.remove('cur');
				last = this.index;
				that.last = last;
			};
		})(this.change[i], this.contentNode[i]), false);
	}

};



dd.prototype.nInit = function() {
	// 初始化只能一次有效
	var bl = true;
	return function(fn) {
		if (!bl) {
			alert('您已初始化过了');
			return;
		}

		bl = false;
		// 激活flow方法
		this.active = true;


		var doc = document;
		var tab = doc.createElement('div');
		tab.className = 'tab1';
		this.domTitle = doc.createElement('div');
		this.domTitle.className = 'title';
		this.domContent = doc.createElement('div');
		this.domContent.className = 'content';

		this.flow();
		// 静态输出
		
		
		


		var that = this;
		this.titleNode[0].classList.add('cur');
		this.contentNode[0].classList.add('cur');


		for (var i = 0, len = this.titleNode.length; i < len; i++) {

			this.domTitle.appendChild(this.titleNode[i]);
			this.domContent.appendChild(this.contentNode[i]);
		}

		tab.appendChild(this.domTitle);
		tab.appendChild(this.domContent);
		return tab;
	};
}();


function createDiv(nodeVlaue) {
	var div = document.createElement('div');
	div.innerHTML = nodeVlaue;
	return div;
}

// 添加数据
var da = new dd();
da.push({
	title : 1,
	content : 1111111111
});




da.push({
	title : 2,
	content : 22222222222
});




da.push({
	title : 3,
	content : 3333333333
});


document.body.appendChild(da.nInit());


</script>
</body>
</html>