★★★★作用域★★★★
作用域
全局作用域和局部作用域统称为词法作用域，局部作用域包括函数作用域和块作用域（let，const），词法作用域就是定义在词法阶段的作用域，也就是在编译阶段的作用域，词法作用域是由你在写代码时将变量写在哪里决定的。
js代码在执行前都要进行编译，大部分编译的情况发生在代码执行前的几微妙，甚至更短。
运行代码段有3个角色，引擎，编译器，作用域。变量的赋值操作会执行2个动作，首先编译器会在当前作用域中声明一个变量，然后引擎运行时会在作用域中查找该变量，如果能够找到就会对他赋值。
尽量用函数表达式少用函数语句，应为函数语句会被提升，造成顺序混乱

每个函数在创建时会设置一个“调用”属性。当调用一个函数是时，可理解为调用此函数的“调用”属性。函数实际上是object的一个子类型，具体来说，函数是“可调用对象”，他有一个内部属性[[call]]，该属性使其可以被调用。
函数的参数不像普通的变量那样被初始化为undefined，而是在该函数调用的时初始化为实际提供的值
function a (b, c) {
	console.log(b, c);//1, 2
	var b = 33;
	var c = 55;
	console.log(b, c);//33, 55
}
a(1, 2);
变量和函数语句的名字同名的时候，那他们提升的时候，函数语句等级比变量高
alert(a);//function a () {}
var a = 1;
function a () {}
let,const声明的变量不提升

★★★★递归★★★★
递归干掉for循环语句
他把一个问题分解成一组相似的子问题，一般来说，一个递归函数调用自身去解决他的子问题。
递归函数可以非常高效的操作树形的数据结构，比如游览器端的dom树，每次递归调用时处理指定的树的一小段。
尾递归是一种在函数的最后执行递归调用语句的特殊形式的递归。
function fact (n) {
	if (n == 0) return 1;
	return n * fact(n - 1);
}
这个不算尾递归，因为最后的运算是乘法。
尾递归为什么性能好，是因为是最后一步，上面父级的函数体运行一次会将永远不会在次使用，所以就释放了调用栈的资源了。
Ross：你先挂！
Julie：不，你先挂！
Ross：不不不，你先挂。。。。。。
这其实就是相互递归。
递归多了会造成栈溢出，其实就是函数的递归调用次数超过了运行时调用栈的深度，递归的运行会造成很多的闭包，不断增加的同时，函数又不能释放，所以调用栈会越来越大，直到溢出。在递归的问题上，没有经过优化的递归其实就是函数调用，而函数调用的过程就是将函数先压入函数调用栈。
递归如何实现深度优先遍历和广度优先遍历？
使用递归进行深克隆。
一个静态的，未调用的函数只是一个值，一旦他（例如函数F）调用时，系统就将当前正在运行的函数（例如函数A）入栈，并保留函数A的执行指针的位置，在函数F执行完毕之后，函数A出栈，并继续执行指针后面的代码：
function F () {
	//......
}
function A () {
	F(x, y, z);
}
A();

★★★★闭包★★★★
闭包其实无处不在，讲到闭包那不得不提词法作用域，js代码的运行分为2个阶段，第一个是编译阶段，编译的阶段形成词法的作用域，第二个是代码运行阶段，运行时的函数产生闭包，一个函数运行其实也是一种广义上的闭包，只不过这种闭包我们没有办法去用到，应为他立即销毁了变量，我们没办法访问到。

当函数可以记住并访问所在的词法作用域时，就产生了闭包。
闭包的特点就是可以阻止函数运行完后整个内部作用域被销毁，事实上内部作用域依然存在，我们依然能访问词法作用域，讲的通俗点就是，函数运行完后变量依然被劫持着，依然能访问到。
使用回调等于使用了闭包。

闭包和循环
for (var i = 1l i <= 5; i++) {
	setTimeout(function timer () {
		console.log(i);
	}, i * 1000);
}
这里打印出来的i并不是我们想要的，理想的情况是我们需要每个迭代在运行时都会有自己捕获的i副本，但实际情况是根据作用域的工作原理，他们都被分封闭在一个共享的全局作用域中，因此实际上只有一个i。所以我们需要自己的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。
for (var i = 1; i <= 5; i++) {
	(function () {
		setTimeout(function timer () {
			console.log(i);
		}, i * 1000);
	})();
}
我们现在显然拥有了更多的词法词法作用域了，但还是不够，因为我们现在只是一个什么都没有的空作用域，我们需要加点实质的内容。
for (var i = 1; i <= 5; i++) {
	(function () {
		var j = i;
		setTimeout(funciton timer () {
			console.log(j);
		}, j * 1000);
	})();
}
改进
for (var i = 1; i <= 5; i++) {
	(function (j) {
		setTimeout(funciton timer () {
			console.log(j);
		}, j * 1000);
	})(i);
}
换句话说，每次迭代我们需要一个块作用域，let其实就能帮我们搞定，因为他可以劫持块作用域。
for (var i = 1; i < 5; i++) {
	let j = i;
	setTimeout(function timer () {
		console.log(j);
	}, j * 1000);
}
改进
for (let i = 1; i < 5; i++) {
	setTimeout(function timer () {
		console.log(i);
	}, i * 1000);
}

闭包和模块
function CoolModule () {
	var something = 'cool';
	var another = [1, 2, 3];
	function doSomething () {
		console.log(something);
	}
	function doAnother () {
		console.log(another.join('!'));
	}
	return {
		doSomethind : doSomething,
		doAnother : doAnother
	};
}
var foo = CoolModule();
foo.doSomething();
foo.doAnother();
这种模式就被称为模块，亦可以把他变成单列模块
1.必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块的实例）
2.封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态

闭包的的各种形式

1.广义形式的闭包
function foo () {
	var a = 2;
	function bar () {
		console.log(a);
	}
	bar();
}
foo();

2.通过函数return出去的闭包
function foo () {
	var a = 2;
	function bar () {
		console.log(a);
	}
	return bar;
}
var baz = foo();
baz();

3.通过变量传递出去的闭包
var fn;
function foo () {
	var a = 2;
	function baz () {
		console.log(a);
	}
	fn = baz;
}
foo();
fn();

4.定时器形成的闭包
function wait (message) {
	setTimeout(function timer () {
		console.log(message);
	}, 1000);
}
wait('hello, closure!');

5.绑定事件时的闭包
function setupBot (name, selector) {
	document.querySelector(selector).addEventListener('click', function () {
		console.log('activating:' + name);
	});
}
setupBot('closure bot', '#bot_1');

回调--也是闭包
函数使得对不连续事件的处理变得更容易----异步
闭包是函数定义的位置通过词法作用域向外捕获变量而形成外部函数活动对象不能销毁的这么一个过程，并不是通过函数运行时的传参，传参是参进去的不是通过词法作用域找的，所以不会形成闭包，这点以前一直搞不清楚，现在清楚了。

★★★★模块★★★★
我们可以使用函数和闭包来构建模块，模块是一个提供接口却隐藏状态和实现的函数或对象，通过使用函数产生模块，我们几乎可以完全摒弃全局变量的使用

★★★★柯理化★★★★
我们把一个多参的函数变成一次只能接受一个参数的函数的过程叫做柯理化。
const data = [{name : 'aa', sex : 'male'}, {name : 'bb', sex : 'male'}, {name : 'cc', sex : 'female'}, ];
我有一些人，我要显示所有性别为男性的人名，通常如果按照underscore的习惯，大概会写成这样：
_.map(_.filter(data, function (d) {
	return d.sex == 'male';
}), function (d) {
	return d.name;
});
使用这种方法的问题是，把数据和过程耦合了，我们再次想想，数据是名词，过程是动词，现在耦合了，过程动作函数就不能复用了。所以可以这样：
const R = require('ramda');
const getMaleName = R.compose(R.map(function (d) {
	return d.name
}), R.filter(function (d) {
	return d.sex == 'male';
}));
getMaleName(data);
他把过程投进去加工，生成一个新的函数，这个新的函数只接受原材料数据，这样就不耦合了，通过这种柯理化的方式把动词过程和名词原材料分开来了。

★★★★记忆★★★★

★★★★惰性求值★★★★

★★★★非惰性求值★★★★
var i = 100;
alert(i+=20, i*=2, 'value:' + i);
alert(i);
在这个例子中第一个输出120，第二个输出240，对于第一个，alert值接受一个参数，尽管alert并没有接受第二，第三个参数，但用于传入第二个参数值得表达式却完成了运算，并实际的向alert传入了值，只不过alert没有使用它而已，由于已经完成了运算，所有后面的alert就输出240了。这里就体现了js的非惰性求值的特性了。如果说一个参数是需要用到时，才完成求值或取值，那么他就是惰性求值的，反之则是非惰性求值。而js使用费惰性求值很大一部分原因，在于他的表达式还支持赋值，这也就意味着表达式会产生对系统的副作用。

★★★★函数式★★★★
面向对象通常被比喻成名词，而函数式编程是动词。面向对象抽象的是对象，对于对象的描述自然是名词。面向对象把所有操作和数据都封装在对象内，通过接收消息做相应的操作。比如Kitty和Pussy，他们可以接收打招呼的消息，然后做相应的动作。而函数式的抽象方式刚好相反，是把动作抽象出来，比如就是一个函数“打招呼”，而参数，则是作为数据传入的Kitty或者Pusssy。
在函数式编程中有个概念叫引用透明性。
不可变性是说不管是什么，在被创建之后就再也不能改变。持久性是指数据结构在被操作的时候永远保持着前一个版本，意思是，因为数据是不可变的，所以改变数据只是创建一个新的副本，一个接一个，这个就是每次改变产生新的版本。
谓词函数是一个判断式，一个返回bool值的函数。谓词自然应该是“是”，“等于”，“大于”，“属于”之类的词。
回调函数。
高阶函数。以一个函数作为参数，返回一个函数作为结果。
泛函数。
前馈函数。
纯函数。
函数是一等公民，所谓一等，就是说跟值一样都是一等公民，所有值能到达的地方都可以替换成函数。
我现在理解的声明式的编程就是不关心某个函数的内部实现，是关心他能干什么，就比如是谓词函数，isNumber，isString，从函数名就能判断这个函数能干什么，而不关心她内部是怎么判断是不是数字，或是字符串的，当然这是从使用者的角度来使用函数式的这么一种编程方式，但她的实现底层我觉得还是命令式的，也有可能我们有了一些函数的积累后就可以组合更大功能的函数了。
函数参数劲量使用函数而不是直接的值，因为值是死的，函数是活的。
有个函数将值进行多次复制：
function repeat (times, value) {
	return _.map(_.range(times), function () {
		return value;
	});
}
repeat(4, 'Major');
这里主要强调一个很重要的观点就是使用函数而不是值。我们可以这样修改，灵活性和就更大了。
function repeatedly (times, fun) {
	return _.map(_.range(times), fun);
}
repeatedly(3, function () {
	return Math.floor((Math.random() * 10) + 1);
});
其实我们把那个3也变成活的就更好了。
组合子。

命令式，说明式，静态语言，动态语言
（现在仅被要求写出代码，而从未了解什么是语言？什么是程序的根本？就像什么是艺术一样，js语言的本质是什么）
（每个人之所以不一样，是因为性格，脾气，思想）
数学函数是集合A的成员到集合B的成员的映射。
函数式程序设计师通过数学函数的定义，应用的说明和求值完成运算过程的。
连续求值是函数式的基本特性。
函数调用是无副作用的。
函数式语言中所谓的函数并不是真正的精髓，真正的精髓在于运算，而函数只是封装运算的一种手段。
函数的调用本质上都是表达式运算，而非语句。
对象的访问也是先通过“.”运算符进行访问然后在通过“()”运算符进行函数调用。
运算都产生值类型的结果，所以一切的逻辑语句结构都可以被消灭。
连续运算来组织代码消灭用顺序语句来组织代码。
命令式语言的三种基本逻辑结构：顺序，分支，循环，在函数式里面都要消灭。
罗列出所有的运算符：
算术运算符：
加法(+)，减法(-)，乘法(*)，除法(/)，求余(%)，幂(**)，递增(++)，递减(--)，一元负号(-)，一元正号(+)
赋值运算符：
赋值	x = y	x = y
加赋值	x += y	x = x + y
减赋值	x -= y	x = x - y
乘赋值	x *= y	x = x * y
除赋值	x /= y	x = x / y
模赋值	x %= y	x = x % y
左移赋值	x <<= y	x = x << y
右移赋值	x >>= y	x = x >> y
无符号右移赋值	x >>>= y	x = x >>> y
按位与赋值	x &= y	x = x & y
按位异或赋值	x ^= y	x = x ^ y
按位或赋值	x |= y	x = x | y
安位运算符：
按位与	a & b
按位或	a | b
按位异或	a ^ b
按位非	~ a
左移	a << b
有符号右移	a >> b
无符号右移	a >>> b
比较运算符：
相等(==)，不相等(!=)，严格相等(===)，严格不相等(!==)，大于(>)，大于等于(>=)，小于(<)，小于等于(<=)
逗号运算符：,,,,,
条件运算符：?:
圆括号运算符:()
逻辑运算符：
逻辑与(&&)，逻辑或(||)，逻辑非(!)
delete运算符
in运算符
instanceof运算符
new运算符
typeof运算符
void运算符
对象访问运算符：(.)，([])
函数调用运算符：()
开始消灭命令式的逻辑结构：
a||b||c||d消除条件语句。
a&&b&&c&&d消除条件语句。
通过表达式消灭分支语句：
if (tag > 1) alert(1);
//装换成
(tag > 1) && alert(1);
(tag > 1) ? alert(1) : null;

if (tag > 1) alert(1); else alert(2);
//转换成
(tag > 1) ? alert(1) : alert(2);

switch (value) {
	100 :
	200 : alert('value is 200 or 100'); break;
	300 : alert('value is 300'); break;
	default : alert('I dont know.');
}
//等效于
if (value == 100 || value == 200) {
	alert('value is 100 or 200');
} else if (value == 300) {
	alert('value is 300');
} else {
	alert('I dont know.');
}
//转换成
(value == 100 || value == 200) ? alert('value is 100 or 200') : (value == 300) ? alert('value is 300') : alert('I dont know');
通过递归消灭循环语句：
var loop = 100;
var i = loop;
do {
	//do something
	i--;
}
while (i > 0);
//转换成
void function (i) {
	//do something
	(--i > 0) && arguments.callee(i);
}(loop);
如果递归多了就会栈溢出，而循环是开销很小的，因为每次递归中需要保留私有数据和上下环境，因此将消耗大量栈空间。但也有不占用栈的情况，那就是尾递归，因为尾递归是最后一个表达式，那么当前函数不需要为下一次调用保持栈和运算上下文环境。
函数式可以不使用寄存器，因此这事实上只需值声明，而不需要变量声明，值参与运算，变量其实是值得寄存，所以在函数式语言中，变量声明语句也不需要。所以你会看到，在函数式语言中，除了值声明和函数返回之外，其他的语句都是可以被消灭的。
在一个函数体内使用循环语句，这会使他表面上看起来并没有彻底消除函数语句，为什么说是表面上看起来呢？因为函数在这里只有值得含义，所以函数只有返回的值在影响系统的运算，无论函数内部如何实现，事实上并不会影响到其外部的系统。
在js中使用函数式风格编程，应首先用表达式连续运算来组织代码。
在面向对象的js中，所有的东西都是对象，在函数式的js中，所有的东西都是值。


所以我现在对函数式的理解就是，函数式是对使用的人来说，用起来的函数式，不需要考虑什么状态，副作用，关注于你的业务就行了，就像一开始用for循环来给dom绑定事件中的i就是个状态变化的副作用，我海得自己处理下i来使用它，才能是在点击事件中正常的使用i，然后使用forEach来绑定事件，就完全不需要去关注这些其他的东西，专心新你的业务就行了，这些副作用，状态已经被写成方法了，使用者无需关心这些，这就是对使用者来说的函数式操作，但是这些方法底层的实现是不是函数式，没有没副作用，都跟使用者无关，底层还是会用变量，for循环，副作用，各种状态，函数式是种思想，并不是特定的写法。


字符串，数组，对象之间方法的call，apply互相调用对方的方法有得玩了，呵呵哒

三天前是星期几？
new Date(new Date() - 3 * 24 * 60 * 60 * 1000).getDay()


